Step 1: 2 related securities ( two securities those have similiraties: same sector / industry/ similar market capitalization/average volume traded.)
Step 2: spread ( pair ratio to indicate the spread==price of asset A / price asset B)
Step 3: mean, standard deviation, and z-score of the pair ratio / spread.
Step 4: Test for co-integration(Augmented Dicky Fuller Test (ADF Test) to test for co-integration. all tests have to reject the null hypothesis that the pair is not co-integrated)
Step 5: Generate trading signals
Step 6: Process transactions based on signals
Step 7: Reporting
*Charting:
An Equity curve
Drawdown curve
Daily returns bar chart
Statistics:
*Annual Returns
Annualized Sharpe Ratio
Maximum Drawdown
Total trades
Success ratio
PnL ratio
*Table:
Top 5 Drawdowns and their duration

#Imports
require(tseries)
require(urca) #Used for the ADF Test
require(PerformanceAnalytics)



#Add Columns to csvDataframe
AddColumns <- function(csvData){
csvData$spread <- 0
csvData$adfTest <- 0
csvData$mean <- 0
csvData$stdev <- 0
csvData$zScore <- 0
csvData$signal <- 0
csvData$BuyPrice <- 0
csvData$SellPrice <- 0
csvData$LongReturn <- 0
csvData$ShortReturn <- 0
csvData$Slippage <- 0
csvData$TotalReturn <- 0
return(csvData)
}







***
http://economics-notepad.blogspot.in/2011/12/markov-switching-pairs-trading-rule.html
http://ses.library.usyd.edu.au/bitstream/2123/4072/1/Thesis_Schmidt.pdf
http://gekkoquant.com/2013/01/21/statistical-arbitrage-trading-a-cointegrated-pair/
https://tspace.library.utoronto.ca/bitstream/1807/65615/1/ZhengqinZeng_20146_MASc_thesis_pdf.pdf
http://myweb.fcu.edu.tw/~chenws/pairs.pdf
http://stat.wharton.upenn.edu/~steele/Courses/434/434Context/PairsTrading/PairsTradingQFin05.pdf
http://www.r-bloggers.com/the-fear-index-is-the-vix-efficient-to-be-warned-about-high-volatility-finance-systematic-processus/
http://www.r-bloggers.com/in-depth-introduction-to-machine-learning-in-15-hours-of-expert-videos/
http://www.gauravbiware.com/pairs-trading-using-correlation-in-r/
http://repository.upenn.edu/cgi/viewcontent.cgi?article=1095&context=wharton_research_scholars
https://www.stat.berkeley.edu/~aldous/Research/Ugrad/Amy_Zhang.pdf
http://mobile.library2.smu.ca/bitstream/handle/01/26133/Bharadwaj_MandaRaghavaSantosh_MRP_2014.pdf?sequence=1&isAllowed=y
http://www.inside-r.org/packages/cran/PairTrading/docs/PairTrading
http://complete-markets.com/2011/03/fin-476-pairs-trade-r-code-trading-period/
http://gekkoquant.com/2012/10/21/statistical-arbitrage-correlation-vs-cointegration/
http://www.marketcalls.in/amibroker/pair-trading-amibroker-afl-code.html
http://files.meetup.com/1704326/TradingStrategies.pdf
https://cran.r-project.org/web/packages/egcm/egcm.pdf
http://gekkoquant.com/2012/10/
http://epchan.blogspot.in/2011/06/when-cointegration-of-pair-breaks-down.html

https://www.quantopian.com/posts/$gld-slash-$iau-pairs-trading-template
https://www.quantopian.com/posts/pairs-trading-algorithm
https://www.quantopian.com/posts/how-to-build-a-pairs-trading-strategy-on-quantopian
https://www.quantopian.com/posts/augmented-dickey-fuller-adf-test-spy-and-sh-dollar-volume
https://www.quantopian.com/posts/pairs-trading-algorithm
https://www.quantopian.com/posts/multiple-pairs-trading-algo
https://www.quantopian.com/posts/pairs-trading-algorithm-1
https://www.quantopian.com/posts/first-attempt-at-pairs-trading
https://www.quantopian.com/posts/questions-on-trading-cointegrated-pairs
https://www.quantopian.com/posts/identifying-cointegrated-pairs-in-a-sector
http://econ.schreiberlin.de/software/vecmclass.py
http://www.ccsenet.org/journal/index.php/ijef/article/view/33007
https://www.quantopian.com/posts/pairs-trading-with-error-correction-model
https://www.quantopian.com/posts/kalman-filter-multiple-pairs-trading
https://www.quantopian.com/posts/pair-trade-using-a-risk-factor-model
https://www.quantopian.com/posts/trading-strategy-worthy-of-q-fund
https://www.quantopian.com/posts/ernie-chan-uso-slash-gld-oil-slash-gold-pair-spread-trading-at-constant-leverage
https://www.quantopian.com/posts/pair-trade-with-cointegration-and-mean-reversion-tests
https://www.quantopian.com/posts/quantopian-lecture-series-this-time-youre-more-wrong?c=1
https://www.quantopian.com/posts/augmented-dickey-fuller-adf-test-spy-and-sh-dollar-volume
https://www.quantopian.com/posts/apt-and-pairs-trading-by-pca-between-spy-and-10-us-market-sectors-2
https://www.quantopian.com/posts/sensitivity-analysis-aka-parameter-optimization-of-pair-trade-input-parameters
https://www.quantopian.com/posts/cointegration-rsi-signals-long-only
https://www.quantopian.com/posts/machine-learning-turn-$10k-into-2-dollars-dot-25m-in-two-years-plus-22407-percent-returns-by-trading-brk-a-berkshire-hathaway-with-random-forest
https://www.quantopian.com/posts/trading-strategy-statistical-arbitrage-and-mean-reversion
https://www.quantopian.com/posts/brent-slash-wti-spread-fetcher-example
https://www.quantopian.com/posts/cvxvsxom
https://www.quantopian.com/posts/what-about-vxup-slash-vxdn
https://www.quantopian.com/posts/further-experiments-with-randomness
https://www.quantopian.com/posts/ernie-chans-ewa-slash-ewc-pair-trade-with-kalman-filter
https://www.quantopian.com/posts/october-prize-number-1-algo-disqualified-worthy-of-the-q-fund
https://www.quantopian.com/posts/very-simple-2-sharpe-algo-on-xle-components
https://www.quantopian.com/posts/improved-minimum-variance-portfolio

https://www.quantopian.com/posts/russell-2000-statistical-arbitrage-with-hedged-stock-pairs-mean-reversion-strategy

import datetime
import pytz
import numpy as np
import pandas as pd
import statsmodels.api as sm

WINDOW_LENGTH = 50 

def ols_transform(prices, sid1, sid2): # receives constantly updated dataframe
    """Computes regression coefficient (slope)
    via Ordinary Least Squares between two SIDs.
    """
    prices = prices.fillna(method='bfill')
    p0 = prices[sid1].values
    p1 = prices[sid2].values
        
    slope = sm.OLS(p0, p1).fit().params[0]
    return slope

def initialize(context):
    context.gld = sid(26807)
    context.iau = sid(26981)
    
    context.rebalance_date = None
    context.rebalance_trigger = 20

    # maximum total exposure (longs - shorts) in $US allowed
    context.max_notional = 1000000 #$30,000

    context.spreads = []
    
    set_commission(commission.PerTrade(cost=1.00))
    set_slippage(slippage.FixedSlippage(spread=0.00))

def handle_data(context, data):
    
    price_history = history(50, '1d', 'price')
    price_history = price_history.fillna(method='ffill')
    
    # Get the current exchange time, in local timezone 
    exchange_time = pd.Timestamp(get_datetime()).tz_convert('US/Eastern')   
    
    
    # Only run the OLS regression once per day at 10:30am
    if exchange_time.hour != 10 or exchange_time.minute != 30:
        return
    
    ######################################################
    # 1. Compute regression coefficient between GLD and IAU using the Ordinary Least Squares method
    # ref: http://en.wikipedia.org/wiki/Ordinary_least_squares
    params = ols_transform(price_history, context.gld, context.iau)
    
    context.slope = params

    ######################################################
    # 2. Compute zscore of spread (remove mean and divide by std), require at least 20 data points before 1st trade
    zscore = compute_zscore(context, data)
    record(zscore=zscore)
    
    if len(context.spreads)<20:
        log.info('fewer than 20 data points to z-score')
        return
    ######################################################
    # 3. Place orders (if its been the required # days since the position was initiated)
    if context.rebalance_date == None:
       place_orders(context, data, zscore, exchange_time)
        
    elif context.rebalance_date and exchange_time > context.rebalance_date + datetime.timedelta(days=context.rebalance_trigger):
        place_orders(context, data, zscore, exchange_time)

def compute_zscore(context, data):
    """1. Compute the spread given slope from the OLS regression
       2. zscore the spread.
    """
    spread = data[context.gld].price - (context.slope * data[context.iau].price)
    # Positive spread means that GLD is priced HIGHER than it should be relative to IAU
    # Negative spread means that GLD is priced LOWER than it should be relative to IAU
    
    context.spreads.append(spread)
          
    zscore = (spread - np.mean(context.spreads[-WINDOW_LENGTH:])) / np.std(context.spreads[-WINDOW_LENGTH:])
    return zscore

def place_orders(context, data, zscore, exchange_time):
    """Buy spread if zscore is > 2, sell if zscore < -2
    """
    # calculate the current notional value of each position
    notional1 = context.portfolio.positions[context.gld].amount * data[context.gld].price
    notional2 = context.portfolio.positions[context.iau].amount * data[context.iau].price
    #record(gld_pos_x10k=(0.0001)*notional1,iau_pos_x10k=(0.0001)*notional2)
    

    bet_size = 500000 #allocate $10,000 per side to the trade
    bet_shares_gld = bet_size / data[context.gld].price
    bet_shares_iau = bet_size / data[context.iau].price
    
    # if our notional invested is non-zero check whether the spread has narrowed to where we want to close positions:
    if abs(notional1) + abs(notional2) != 0:
        if zscore <= 0.5 and zscore >= -0.5:
            close_position(context, context.gld, data)
            close_position(context, context.iau, data)
            log.info('closing positions')
        else:
            return
        
    # if our notional invested is zero, check whether the spread has widened to where we want to open positions:
    elif abs(notional1) + abs(notional2) == 0:
        if zscore >= 2.0:
            # sell the spread, betting it will narrow since it is over 2 std deviations
            # away from the average
            order(context.gld, -1 * bet_shares_gld)
            order(context.iau, bet_shares_iau)
            log.info('z-score > 2, selling the spread')
            context.rebalance_date = exchange_time
    
        elif zscore <= -2.0:
            # buy the spread
            order(context.gld, bet_shares_gld)
            order(context.iau, -1 * bet_shares_iau)
            log.info('z-score < 2, buying the spread')
            context.rebalance_date = exchange_time


def close_position(context, stock, data):
    """
    decrease exposure to zero, regardless of position long/short.
    buy for a short position, sell for a long.
    """
    pos_amount = context.portfolio.positions[stock].amount
    order(stock, -1 * pos_amount)

******* ANOTHER

import numpy as np
import statsmodels.api as sm
import pandas as pd
from zipline.utils import tradingcalendar
import pytz


def initialize(context):
    # Quantopian backtester specific variables
    set_slippage(slippage.FixedSlippage(spread=0))
    set_commission(commission.PerTrade(cost=1))
    set_symbol_lookup_date('2014-01-01')
    context.Y = symbol('XLU')
    context.X = symbol('UWTI')
    # set_benchmark(context.y)
    
    
    # strategy specific variables
    context.lookback = 20 # used for regression
    context.z_window = 20 # used for zscore calculation, must be <= lookback
    
    context.useHRlag = True
    context.HRlag = 2
    
    context.spread = np.array([])
    context.hedgeRatioTS = np.array([])
    context.inLong = False
    context.inShort = False
    context.entryZ = 1.0
    context.exitZ = 0.0

    if not context.useHRlag:
        # a lag of 1 means no-lag, this is used for np.array[-1] indexing
        context.HRlag = 1
        
# Will be called on every trade event for the securities you specify. 
def handle_data(context, data):
   
    _Y_value = context.portfolio.positions[context.Y].amount * context.portfolio.positions[context.Y].last_sale_price
    _X_value = context.portfolio.positions[context.X].amount * context.portfolio.positions[context.X].last_sale_price
    _leverage = (abs(_Y_value) + abs(_X_value)) / context.portfolio.portfolio_value
    record(
            X_value = _X_value ,
            Y_value = _Y_value ,
            leverage = _leverage
    )
    
    if get_open_orders():
        return
    
    now = get_datetime()
    exchange_time = now.astimezone(pytz.timezone('US/Eastern'))
    
    if not (exchange_time.hour == 15 and exchange_time.minute == 30):
        return
    
    prices = history(35, '1d', 'price').iloc[-context.lookback::]

    Y = prices[context.Y]
    X = prices[context.X]

    try:
        hedge = hedge_ratio(Y, X, add_const=True)      
    except ValueError as e:
        log.debug(e)
        return
    
    context.hedgeRatioTS = np.append(context.hedgeRatioTS, hedge)
    # Calculate the current day's spread and add it to the running tally
    if context.hedgeRatioTS.size < context.HRlag:
        return
    # Grab the previous day's hedgeRatio
    hedge = context.hedgeRatioTS[-context.HRlag]  
    context.spread = np.append(context.spread, Y[-1] - hedge * X[-1])

    if context.spread.size > context.z_window:
        # Keep only the z-score lookback period
        spreads = context.spread[-context.z_window:]
        
        zscore = (spreads[-1] - spreads.mean()) / spreads.std()
          
        if context.inShort and zscore < 0.0:
            order_target(context.Y, 0)
            order_target(context.X, 0)
            context.inShort = False
            context.inLong = False
            record(X_pct=0, Y_pct=0)
            return
        
        if context.inLong and zscore > 0.0:
            order_target(context.Y, 0)
            order_target(context.X, 0)
            context.inShort = False
            context.inLong = False
            record(X_pct=0, Y_pct=0)
            return
            
        if zscore < -1.0 and (not context.inLong):
            # Only trade if NOT already in a trade
            y_target_shares = 1
            X_target_shares = -hedge
            context.inLong = True
            context.inShort = False
            
            (y_target_pct, x_target_pct) = computeHoldingsPct( y_target_shares,X_target_shares, Y[-1], X[-1] )
            order_target_percent(context.Y, y_target_pct)
            order_target_percent(context.X, x_target_pct)
            record(Y_pct=y_target_pct, X_pct=x_target_pct)
            return

        if zscore > 1.0 and (not context.inShort):
            # Only trade if NOT already in a trade
            y_target_shares = -1
            X_target_shares = hedge
            context.inShort = True
            context.inLong = False
           
            (y_target_pct, x_target_pct) = computeHoldingsPct( y_target_shares, X_target_shares, Y[-1], X[-1] )
            order_target_percent(context.Y, y_target_pct)
            order_target_percent(context.X, x_target_pct)
            record(Y_pct=y_target_pct, X_pct=x_target_pct)


def is_market_close(dt):
    ref = tradingcalendar.canonicalize_datetime(dt)
    return dt == tradingcalendar.open_and_closes.T[ref]['market_close']

def hedge_ratio(Y, X, add_const=True):
    if add_const:
        X = sm.add_constant(X)
        model = sm.OLS(Y, X).fit()
        return model.params[1]
    model = sm.OLS(Y, X).fit()
    return model.params.values
    
def computeHoldingsPct(yShares, xShares, yPrice, xPrice):
    yDol = yShares * yPrice
    xDol = xShares * xPrice
    notionalDol =  abs(yDol) + abs(xDol)
    y_target_pct = yDol / notionalDol
    x_target_pct = xDol / notionalDol
    return (y_target_pct, x_target_pct)

*****
getSymbols(c("SPY","USO","UCO","IWM","EEM","ECH","TLT","EWB","IWO","RSP","EWRS","TNA","UDOW","UPRO","VXX","XXV","KOLD","BOIL","ERX","ERY","NUGT","DUST"))

y1<-BOIL
y2<-KOLD
y<-merge(tail(y1,1000),tail(y2,1000))
rolling_correlation<-rollapply(y,width=50,FUN=function(y) cor(y[,1],y[,2]),by.column = FALSE, align = "right")
plot(rolling_correlation)

##Rolling Correlation
getSymbols(c("FAS","FAZ"))
y1<-Cl(FAS)
y2<-Cl(FAZ)
y<-merge(tail(y1,1000),tail(y2,1000))
rolling_correlation<-rollapply(y,width=50,FUN=function(y) cor(y[,1],y[,2]),by.column = FALSE, align = "right")
plot(tail(rolling_correlation,250))
##Rolling Regression
rr <- rollapply(y, width = 36,FUN = function(y) coef(lm(y[,1] ~ y[,2], data = as.data.frame(y))),by.column = FALSE, align = "right")
plot(tail(rr[,1],50))
plot(tail(rr[,2],50))


KOLD-BOIL
ERX-ERY
NUGT-DUST
SQQQ-TQQQ
FAS FAZ
OIL-USO
DIA-SPY
DIA-TLT
XLU-XLF
XLU-USO
XLU-UWTI
TQQQ-UWTI
EWW-EWP
EWC-EWA

** LOOK AHEAD BIAS
** SURVIVAL BIAS
**OVERFITTING






    DBO - DTO (PowerShares DB Oil Fund - Powershares DB Crude Oil Double Short ETN)
    DBO - GAZ (PowerShares DB Oil Fund - iPath Dow Jones-UBS Natural Gas Subindex Total Return ETN)
    DBO - USO (PowerShares DB Oil Fund - United States Oil Fund LP )
    AMJ - DBO (JPMorgan Alerian MLP Index ETN - PowerShares DB Oil Fund )
    DBO - UNG (PowerShares DB Oil Fund - United States Natural Gas Fund, LP)
    DBO - OIL (PowerShares DB Oil Fund - iPath S&P GSCI Crude Oil Total Return)
    DBO - SCO (PowerShares DB Oil Fund - ProShares UltraShort DJ-UBS Crude Oi ETF)
    DBO - UGA (PowerShares DB Oil Fund - United States Gasoline Fund, LP)
    DTO - UCO (Powershares DB Crude Oil Double Short ETN - ProShares Ultra DJ-UBS Crude Oil)
    GAZ - UCO (iPath Dow Jones-UBS Natural Gas Subindex Total Return ETN - ProShares Ultra DJ-UBS Crude Oil)
    UCO - USO (ProShares Ultra DJ-UBS Crude Oil - United States Oil Fund LP )
    UCO - UNG (ProShares Ultra DJ-UBS Crude Oil - United States Natural Gas Fund, LP)
    OIL - UCO (iPath S&P GSCI Crude Oil Total Return - ProShares Ultra DJ-UBS Crude Oil)
    SCO - UCO (ProShares UltraShort DJ-UBS Crude Oi ETF - ProShares Ultra DJ-UBS Crude Oil)
    DTO - GAZ (Powershares DB Crude Oil Double Short ETN - iPath Dow Jones-UBS Natural Gas Subindex Total Return ETN)
    DTO - USO (Powershares DB Crude Oil Double Short ETN - United States Oil Fund LP )
    AMJ - DTO (JPMorgan Alerian MLP Index ETN - Powershares DB Crude Oil Double Short ETN)
    DTO - UNG (Powershares DB Crude Oil Double Short ETN - United States Natural Gas Fund, LP)
    DTO - UGA (Powershares DB Crude Oil Double Short ETN - United States Gasoline Fund, LP)
    GAZ - USO (iPath Dow Jones-UBS Natural Gas Subindex Total Return ETN - United States Oil Fund LP )

http://www.pairslog.com/pairsList.php?startPos=20&
http://seekingalpha.com/article/3070136-shorting-leveraged-etf-pairs-easier-said-than-done
http://seekingalpha.com/article/1254391-3-leveraged-etf-pairs-to-short

getSymbols(c("SPY","USO","UCO","IWM","EEM","ECH","TLT","EWB","IWO","RSP","EWRS","TNA","UDOW","UPRO","VXX","XXV","KOLD","BOIL","ERX","ERY","NUGT","DUST"))

y1<-BOIL
y2<-KOLD
y<-merge(tail(y1,1000),tail(y2,1000))
rolling_correlation<-rollapply(y,width=50,FUN=function(y) cor(y[,1],y[,2]),by.column = FALSE, align = "right")
plot(rolling_correlation)

##Rolling Correlation
getSymbols(c("FAS","FAZ"))
y1<-Cl(FAS)
y2<-Cl(FAZ)
y<-merge(tail(y1,1000),tail(y2,1000))
rolling_correlation<-rollapply(y,width=50,FUN=function(y) cor(y[,1],y[,2]),by.column = FALSE, align = "right")
plot(tail(rolling_correlation,250))
##Rolling Regression
rr <- rollapply(y, width = 36,FUN = function(y) coef(lm(y[,1] ~ y[,2], data = as.data.frame(y))),by.column = FALSE, align = "right")
plot(tail(rr[,1],50))
plot(tail(rr[,2],50))

getSymbols(c("NUGT","DUST"))
ratio<-na.omit(Cl(NUGT)/Cl(DUST))
ra <- rollapply(ratio, width = 36,FUN = function(ratio) forecast.Arima(arima(ratio, order=c(2,1,2)), data = as.data.frame(ratio),by.column = FALSE, align = "right") 

arima <- arima(na.omit(ratio), order=c(2,0,2)) # fit an ARIMA(p,d,q) model
arimaforecasts <- forecast.Arima(arima, h=1)
arimaforecasts 
http://gekkoquant.com/2013/01/21/statistical-arbitrage-trading-a-cointegrated-pair/
http://www.rfortraders.com/lecture-4-regression-and-pairs-trading/
http://www.r-bloggers.com/simulating-backtests-of-stock-returns-using-monte-carlo-and-snowfall-in-parallel/
http://www.r-bloggers.com/pair-trading-strategy-how-to-use-pairtrading-package/
library("zoo", lib.loc="~/R/win-library/3.1")
coke_dates <- as.Date(coke[,1])
pep_dates  <- as.Date(pep[,1])
cc         <- zoo(coke[,5], coke_dates)
pp         <- zoo(pep[,5], pep_dates)
t.zoo      <- merge(cc, pp, all=FALSE)
t          <- as.data.frame(t.zoo)
r1         <- princomp( ~ log(coke$Close) + log(pep$Close))
slope1     <- r1$loadings[2,1]/r1$loadings[1,1]
prd        <- t$cc - slope1*t$pp
library(tseries)
ht         <- adf.test(prd, alternative="stationary", k=0)


http://repository.upenn.edu/cgi/viewcontent.cgi?article=1095&context=wharton_research_scholars
http://www.gauravbiware.com/pairs-trading-using-correlation-in-r/
https://www.stat.berkeley.edu/~aldous/Research/Ugrad/Amy_Zhang.pdf
http://mysimplequant.blogspot.in/2011/02/learning-spread-trades.html
https://www.quantopian.com/posts/writing-a-thesis-on-pair-trading-strategies-should-i-use-quantopian-for-research

http://stackoverflow.com/questions/30178611/pairs-trading-in-r-calculating-and-maximizing-profit
http://www.yats.com/doc/cointegration-en.html
https://sinamotamedi.wordpress.com/2009/04/16/pairs-trading-in-r/
http://swfa2015.uno.edu/B_Asset_Pricing_III/paper_196.pdf
https://www3.nd.edu/~pgao/papers/EngelbergGaoJag_31August2008.pdf
http://mobile.library2.smu.ca/bitstream/handle/01/26133/Bharadwaj_MandaRaghavaSantosh_MRP_2014.pdf?sequence=1&isAllowed=y
http://files.meetup.com/1704326/TradingStrategies.pdf

https://cran.r-project.org/web/views/TimeSeries.html
https://cran.r-project.org/web/views/Econometrics.html
https://cran.r-project.org/web/views/Finance.html
https://github.com/ljump12/Pairs-Trading/blob/master/pairs.R
http://r.789695.n4.nabble.com/How-to-test-pairs-trading-strategy-td3558776.html
http://remington-research.blogspot.in/2013/04/cointegration-pair-trading.html
http://coin.wne.uw.edu.pl/pwojcik/hfd_en.html
https://www.coursehero.com/file/6904571/Section-7-R-code/
http://waxworksmath.com/authors/n_z/vidyamurthy/writeup/weatherwax_vidyamurthy_notes.pdf
http://brage.bibsys.no/xmlui/bitstream/handle/11250/221265/masterthesis.pdf?sequence=1
http://ses.library.usyd.edu.au/bitstream/2123/4072/1/Thesis_Schmidt.pdf
http://www.aueb.gr/conferences/Crete2011/more%20recent/Schizas.pdf
https://www.ucc.ie/en/media/research/centreforinvestmentresearch/wp/PT2.5.pdf

************
Pairs trading is typically classified as an EMN investment strategy that is based on short term price reversal.  The strategy, characterised in industry as a form of statistical arbitrage, involves finding two stocks that follow a similar trading pattern.  When the stock prices deviate from a specified trading rule, positions are taken long in the lower priced security and short in the higher priced security, with the expectation that prices will converge.  The strategy derives returns from the well documented cross autocorrelation in stocks.  Recent microstructure research has documented the relationship between liquidity and cross-autocorrelation and Engelberg,Gao, and Jagannathan (2009)  show that when information is common, market frictions such as illiquidity cause a lead lag relationship in pairs of stocks,  leading to profitable pairs trading. 

Elliott, Van Der Hoek, and Malcolm (2005) use a Gaussian Markov chain model for the spread while Do, Faff, and Hamza (2006) make adaptations for spread measurement based on theoretical asset pricing methods and mean reversion. Vidyamurthy (2004) and Burgess (2005) utilize cointegration for pairs selection, while Papadakis and Wysocki (2007) expand on the methodology of Gatev et al. (2006) by examining the impact of accounting information events 
(i.e. earnings announcements and analyst forecasts) on the level of returns of the pairs trading strategy.

1. Evidence on the profitability of the strategy in the INDIA
2. Analysis of the strategy during the 2008 financial crisis highlighting that unlike other EMN strategies, pairs trading performed 
well in the crisis.
3. Comprehensive analysis of the risks in the strategy using a multi-factor model framework
4. Time series performance of the strategy with equity market liquidity, price impact and different estimates of bid ask spreads.
5. We provide an analysis of the performance of the strategy across different market and economic states
6. 


Elliott, Van Der Hoek, and Malcolm (2005) use a Gaussian Markov chain model for the spread while Do, Faff, and Hamza (2006) make adaptations for spread measurement based on theoretical asset pricing methods and mean reversion. Vidyamurthy (2004) and Burgess (2005) utilize cointegration for pairs selection, while Papadakis and Wysocki (2007) expand on the methodology of Gatev et al. (2006) by examining the impact of accounting information events 
(i.e. earnings announcements and analyst forecasts) on the level of returns of the pairs trading strategy.


To examine the risk exposure of the pairs trading portfolios, the returns are regressed against the common equity factors, market, size, value, momentum, and reversal.  Overall, only the market factor is significantly related to the top five and twenty pairs trading portfolios and the factor model has low explanatory power.  When the portfolio is separated into long and short portfolios the exposure to common risk factors greatly increases.  Exposure to the market and size factor is positive and significant for the long portfolios and negative and significant for the short portfolios, whereas when the portfolios are combined the systematic risk exposure is hedged.   


To ensure our results are directly comparable to the US, and to avoid potential data-mining bias, the methodology closely follows the work of Gatev et al. (2006).  The pairs trading portfolio is formed over two periods, a formation and trading period.  Pairs of stocks are matched during a twelve month formation period, based on a specified trading rule and traded during a six month period immediately following the formation period. Transaction costs are modelled using an estimate of the bid ask spread.  Later in the paper, to test the robustness of transaction cost estimates from Gatev et al. (2006), we provide additional transaction cost estimates based upon both the quoted spread and effective spread (Roll (1984)). 

Pairs are formed by matching each stock with a second     stock   that   has   the   minimum sum of squared deviations between the normalized price series over the twelve month formation period.  The top five and twenty pairs, ranked by minimum sum of squared deviation, are matched at the end of each formation period and are traded over the following six month trading period.

https://www.ucc.ie/en/media/research/centreforinvestmentresearch/wp/PT2.5.pdf
http://www.aueb.gr/conferences/Crete2011/more%20recent/Schizas.pdf
http://www.r-bloggers.com/using-cart-for-stock-market-forecasting/
http://www.quantinsti.com/blog/epat-project-student-jacques-joubert/

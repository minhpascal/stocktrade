http://economics-notepad.blogspot.in/2011/12/markov-switching-pairs-trading-rule.html
http://ses.library.usyd.edu.au/bitstream/2123/4072/1/Thesis_Schmidt.pdf
http://gekkoquant.com/2013/01/21/statistical-arbitrage-trading-a-cointegrated-pair/
https://tspace.library.utoronto.ca/bitstream/1807/65615/1/ZhengqinZeng_20146_MASc_thesis_pdf.pdf
http://myweb.fcu.edu.tw/~chenws/pairs.pdf
http://stat.wharton.upenn.edu/~steele/Courses/434/434Context/PairsTrading/PairsTradingQFin05.pdf
http://www.r-bloggers.com/the-fear-index-is-the-vix-efficient-to-be-warned-about-high-volatility-finance-systematic-processus/
http://www.r-bloggers.com/in-depth-introduction-to-machine-learning-in-15-hours-of-expert-videos/
http://www.gauravbiware.com/pairs-trading-using-correlation-in-r/
http://repository.upenn.edu/cgi/viewcontent.cgi?article=1095&context=wharton_research_scholars
https://www.stat.berkeley.edu/~aldous/Research/Ugrad/Amy_Zhang.pdf
http://mobile.library2.smu.ca/bitstream/handle/01/26133/Bharadwaj_MandaRaghavaSantosh_MRP_2014.pdf?sequence=1&isAllowed=y
http://www.inside-r.org/packages/cran/PairTrading/docs/PairTrading
http://complete-markets.com/2011/03/fin-476-pairs-trade-r-code-trading-period/
http://gekkoquant.com/2012/10/21/statistical-arbitrage-correlation-vs-cointegration/
http://www.marketcalls.in/amibroker/pair-trading-amibroker-afl-code.html
http://files.meetup.com/1704326/TradingStrategies.pdf
https://cran.r-project.org/web/packages/egcm/egcm.pdf
http://gekkoquant.com/2012/10/
http://epchan.blogspot.in/2011/06/when-cointegration-of-pair-breaks-down.html

https://www.quantopian.com/posts/$gld-slash-$iau-pairs-trading-template
https://www.quantopian.com/posts/pairs-trading-algorithm
https://www.quantopian.com/posts/how-to-build-a-pairs-trading-strategy-on-quantopian
https://www.quantopian.com/posts/augmented-dickey-fuller-adf-test-spy-and-sh-dollar-volume
https://www.quantopian.com/posts/pairs-trading-algorithm
https://www.quantopian.com/posts/multiple-pairs-trading-algo
https://www.quantopian.com/posts/pairs-trading-algorithm-1
https://www.quantopian.com/posts/first-attempt-at-pairs-trading
https://www.quantopian.com/posts/questions-on-trading-cointegrated-pairs
https://www.quantopian.com/posts/identifying-cointegrated-pairs-in-a-sector
http://econ.schreiberlin.de/software/vecmclass.py
http://www.ccsenet.org/journal/index.php/ijef/article/view/33007
https://www.quantopian.com/posts/pairs-trading-with-error-correction-model
https://www.quantopian.com/posts/kalman-filter-multiple-pairs-trading
https://www.quantopian.com/posts/pair-trade-using-a-risk-factor-model
https://www.quantopian.com/posts/trading-strategy-worthy-of-q-fund
https://www.quantopian.com/posts/ernie-chan-uso-slash-gld-oil-slash-gold-pair-spread-trading-at-constant-leverage
https://www.quantopian.com/posts/pair-trade-with-cointegration-and-mean-reversion-tests
https://www.quantopian.com/posts/quantopian-lecture-series-this-time-youre-more-wrong?c=1
https://www.quantopian.com/posts/augmented-dickey-fuller-adf-test-spy-and-sh-dollar-volume
https://www.quantopian.com/posts/apt-and-pairs-trading-by-pca-between-spy-and-10-us-market-sectors-2
https://www.quantopian.com/posts/sensitivity-analysis-aka-parameter-optimization-of-pair-trade-input-parameters
https://www.quantopian.com/posts/cointegration-rsi-signals-long-only
https://www.quantopian.com/posts/machine-learning-turn-$10k-into-2-dollars-dot-25m-in-two-years-plus-22407-percent-returns-by-trading-brk-a-berkshire-hathaway-with-random-forest
https://www.quantopian.com/posts/trading-strategy-statistical-arbitrage-and-mean-reversion
https://www.quantopian.com/posts/brent-slash-wti-spread-fetcher-example
https://www.quantopian.com/posts/cvxvsxom
https://www.quantopian.com/posts/what-about-vxup-slash-vxdn
https://www.quantopian.com/posts/further-experiments-with-randomness
https://www.quantopian.com/posts/ernie-chans-ewa-slash-ewc-pair-trade-with-kalman-filter
https://www.quantopian.com/posts/october-prize-number-1-algo-disqualified-worthy-of-the-q-fund
https://www.quantopian.com/posts/very-simple-2-sharpe-algo-on-xle-components
https://www.quantopian.com/posts/improved-minimum-variance-portfolio

https://www.quantopian.com/posts/russell-2000-statistical-arbitrage-with-hedged-stock-pairs-mean-reversion-strategy

import datetime
import pytz
import numpy as np
import pandas as pd
import statsmodels.api as sm

WINDOW_LENGTH = 50 

def ols_transform(prices, sid1, sid2): # receives constantly updated dataframe
    """Computes regression coefficient (slope)
    via Ordinary Least Squares between two SIDs.
    """
    prices = prices.fillna(method='bfill')
    p0 = prices[sid1].values
    p1 = prices[sid2].values
        
    slope = sm.OLS(p0, p1).fit().params[0]
    return slope

def initialize(context):
    context.gld = sid(26807)
    context.iau = sid(26981)
    
    context.rebalance_date = None
    context.rebalance_trigger = 20

    # maximum total exposure (longs - shorts) in $US allowed
    context.max_notional = 1000000 #$30,000

    context.spreads = []
    
    set_commission(commission.PerTrade(cost=1.00))
    set_slippage(slippage.FixedSlippage(spread=0.00))

def handle_data(context, data):
    
    price_history = history(50, '1d', 'price')
    price_history = price_history.fillna(method='ffill')
    
    # Get the current exchange time, in local timezone 
    exchange_time = pd.Timestamp(get_datetime()).tz_convert('US/Eastern')   
    
    
    # Only run the OLS regression once per day at 10:30am
    if exchange_time.hour != 10 or exchange_time.minute != 30:
        return
    
    ######################################################
    # 1. Compute regression coefficient between GLD and IAU using the Ordinary Least Squares method
    # ref: http://en.wikipedia.org/wiki/Ordinary_least_squares
    params = ols_transform(price_history, context.gld, context.iau)
    
    context.slope = params

    ######################################################
    # 2. Compute zscore of spread (remove mean and divide by std), require at least 20 data points before 1st trade
    zscore = compute_zscore(context, data)
    record(zscore=zscore)
    
    if len(context.spreads)<20:
        log.info('fewer than 20 data points to z-score')
        return
    ######################################################
    # 3. Place orders (if its been the required # days since the position was initiated)
    if context.rebalance_date == None:
       place_orders(context, data, zscore, exchange_time)
        
    elif context.rebalance_date and exchange_time > context.rebalance_date + datetime.timedelta(days=context.rebalance_trigger):
        place_orders(context, data, zscore, exchange_time)

def compute_zscore(context, data):
    """1. Compute the spread given slope from the OLS regression
       2. zscore the spread.
    """
    spread = data[context.gld].price - (context.slope * data[context.iau].price)
    # Positive spread means that GLD is priced HIGHER than it should be relative to IAU
    # Negative spread means that GLD is priced LOWER than it should be relative to IAU
    
    context.spreads.append(spread)
          
    zscore = (spread - np.mean(context.spreads[-WINDOW_LENGTH:])) / np.std(context.spreads[-WINDOW_LENGTH:])
    return zscore

def place_orders(context, data, zscore, exchange_time):
    """Buy spread if zscore is > 2, sell if zscore < -2
    """
    # calculate the current notional value of each position
    notional1 = context.portfolio.positions[context.gld].amount * data[context.gld].price
    notional2 = context.portfolio.positions[context.iau].amount * data[context.iau].price
    #record(gld_pos_x10k=(0.0001)*notional1,iau_pos_x10k=(0.0001)*notional2)
    

    bet_size = 500000 #allocate $10,000 per side to the trade
    bet_shares_gld = bet_size / data[context.gld].price
    bet_shares_iau = bet_size / data[context.iau].price
    
    # if our notional invested is non-zero check whether the spread has narrowed to where we want to close positions:
    if abs(notional1) + abs(notional2) != 0:
        if zscore <= 0.5 and zscore >= -0.5:
            close_position(context, context.gld, data)
            close_position(context, context.iau, data)
            log.info('closing positions')
        else:
            return
        
    # if our notional invested is zero, check whether the spread has widened to where we want to open positions:
    elif abs(notional1) + abs(notional2) == 0:
        if zscore >= 2.0:
            # sell the spread, betting it will narrow since it is over 2 std deviations
            # away from the average
            order(context.gld, -1 * bet_shares_gld)
            order(context.iau, bet_shares_iau)
            log.info('z-score > 2, selling the spread')
            context.rebalance_date = exchange_time
    
        elif zscore <= -2.0:
            # buy the spread
            order(context.gld, bet_shares_gld)
            order(context.iau, -1 * bet_shares_iau)
            log.info('z-score < 2, buying the spread')
            context.rebalance_date = exchange_time


def close_position(context, stock, data):
    """
    decrease exposure to zero, regardless of position long/short.
    buy for a short position, sell for a long.
    """
    pos_amount = context.portfolio.positions[stock].amount
    order(stock, -1 * pos_amount)

******* ANOTHER

import numpy as np
import statsmodels.api as sm
import pandas as pd
from zipline.utils import tradingcalendar
import pytz


def initialize(context):
    # Quantopian backtester specific variables
    set_slippage(slippage.FixedSlippage(spread=0))
    set_commission(commission.PerTrade(cost=1))
    set_symbol_lookup_date('2014-01-01')
    context.Y = symbol('XLU')
    context.X = symbol('UWTI')
    # set_benchmark(context.y)
    
    
    # strategy specific variables
    context.lookback = 20 # used for regression
    context.z_window = 20 # used for zscore calculation, must be <= lookback
    
    context.useHRlag = True
    context.HRlag = 2
    
    context.spread = np.array([])
    context.hedgeRatioTS = np.array([])
    context.inLong = False
    context.inShort = False
    context.entryZ = 1.0
    context.exitZ = 0.0

    if not context.useHRlag:
        # a lag of 1 means no-lag, this is used for np.array[-1] indexing
        context.HRlag = 1
        
# Will be called on every trade event for the securities you specify. 
def handle_data(context, data):
   
    _Y_value = context.portfolio.positions[context.Y].amount * context.portfolio.positions[context.Y].last_sale_price
    _X_value = context.portfolio.positions[context.X].amount * context.portfolio.positions[context.X].last_sale_price
    _leverage = (abs(_Y_value) + abs(_X_value)) / context.portfolio.portfolio_value
    record(
            X_value = _X_value ,
            Y_value = _Y_value ,
            leverage = _leverage
    )
    
    if get_open_orders():
        return
    
    now = get_datetime()
    exchange_time = now.astimezone(pytz.timezone('US/Eastern'))
    
    if not (exchange_time.hour == 15 and exchange_time.minute == 30):
        return
    
    prices = history(35, '1d', 'price').iloc[-context.lookback::]

    Y = prices[context.Y]
    X = prices[context.X]

    try:
        hedge = hedge_ratio(Y, X, add_const=True)      
    except ValueError as e:
        log.debug(e)
        return
    
    context.hedgeRatioTS = np.append(context.hedgeRatioTS, hedge)
    # Calculate the current day's spread and add it to the running tally
    if context.hedgeRatioTS.size < context.HRlag:
        return
    # Grab the previous day's hedgeRatio
    hedge = context.hedgeRatioTS[-context.HRlag]  
    context.spread = np.append(context.spread, Y[-1] - hedge * X[-1])

    if context.spread.size > context.z_window:
        # Keep only the z-score lookback period
        spreads = context.spread[-context.z_window:]
        
        zscore = (spreads[-1] - spreads.mean()) / spreads.std()
          
        if context.inShort and zscore < 0.0:
            order_target(context.Y, 0)
            order_target(context.X, 0)
            context.inShort = False
            context.inLong = False
            record(X_pct=0, Y_pct=0)
            return
        
        if context.inLong and zscore > 0.0:
            order_target(context.Y, 0)
            order_target(context.X, 0)
            context.inShort = False
            context.inLong = False
            record(X_pct=0, Y_pct=0)
            return
            
        if zscore < -1.0 and (not context.inLong):
            # Only trade if NOT already in a trade
            y_target_shares = 1
            X_target_shares = -hedge
            context.inLong = True
            context.inShort = False
            
            (y_target_pct, x_target_pct) = computeHoldingsPct( y_target_shares,X_target_shares, Y[-1], X[-1] )
            order_target_percent(context.Y, y_target_pct)
            order_target_percent(context.X, x_target_pct)
            record(Y_pct=y_target_pct, X_pct=x_target_pct)
            return

        if zscore > 1.0 and (not context.inShort):
            # Only trade if NOT already in a trade
            y_target_shares = -1
            X_target_shares = hedge
            context.inShort = True
            context.inLong = False
           
            (y_target_pct, x_target_pct) = computeHoldingsPct( y_target_shares, X_target_shares, Y[-1], X[-1] )
            order_target_percent(context.Y, y_target_pct)
            order_target_percent(context.X, x_target_pct)
            record(Y_pct=y_target_pct, X_pct=x_target_pct)


def is_market_close(dt):
    ref = tradingcalendar.canonicalize_datetime(dt)
    return dt == tradingcalendar.open_and_closes.T[ref]['market_close']

def hedge_ratio(Y, X, add_const=True):
    if add_const:
        X = sm.add_constant(X)
        model = sm.OLS(Y, X).fit()
        return model.params[1]
    model = sm.OLS(Y, X).fit()
    return model.params.values
    
def computeHoldingsPct(yShares, xShares, yPrice, xPrice):
    yDol = yShares * yPrice
    xDol = xShares * xPrice
    notionalDol =  abs(yDol) + abs(xDol)
    y_target_pct = yDol / notionalDol
    x_target_pct = xDol / notionalDol
    return (y_target_pct, x_target_pct)

*****
